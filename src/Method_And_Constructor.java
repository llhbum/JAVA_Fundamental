public class Method_And_Constructor {
    public static void main(String[] args) {

        /*
        ** 메소드의 개념
            * 메소드
                - 자바에서 클래스는 멤버로 속성을 표현하는 필드와 기능을 표현하는 메소드를 가집니다.
                - 그중에서 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있습니다.

            * 메소드의 사용 목적
                - 클래스에서 메소드를 작성하여 사용하는 이유는 중복되는 코드의 반복적인 프로그래밍을 피할 수 있기 때문입니다.
                - 또한 모듈화로 인해 코드의 가독성도 좋아집니다.
                - 그리고 프로그램에 문제가 발생하거나 기능의 변경이 필요할 떄도 손쉽게 유지보수를 할 수 있게 됩니다.

            * 메소드의 정의
                - 클래스에서 메소드를 정의하는 방법은 일반 함수를 정의하는 방법과 크게 다르지 않습니다.
                - 자바에서 메소드를 정의하는 방법은 다음과 같습니다.

                접근제어자 반환타입 메소드이름(매개변수목록) { // 선언부
                    // 구현부
                }

                1. 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시합니다.
                2. 반환 타입(return type): 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시합니다.
                3. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시합니다.
                4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시합니다.
                5. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합입니다.

            * 메소드 호출
                - 자바에서 위와 같은 방법으로 정의한 메소드는 멤버 참조 연산자(.)를 사용하여 호출할 수 있습니다.
                문법
                1. 객체참조변수이름.메소드이름();                  // 매개변수가 없는 메소드의 호출
                2. 객체참조변수이름.메소드이름(인수1, 인수2, ...); // 매개변수가 있는 메소드의 호출

        ** 생성자
            * 인스턴스 변수의 초기화
                - 클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성됩니다.
                - 하지만 이헐게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태입니다.
                - 자바에서 클래스 변수와 인스턴스 변수는 별도로 초기화하지 않으면 자동 초기화됩니다.

                - 하지만 사용자가 원하는 값으로 인스턴스 변수를 초기화하려면, 일반적인 초기화 방식으로는 초기화 할 수 없습니다.
                - 인스턴스 변수 중에는 private 변수도 있으며, 이러한 private 변수에는 사용자나 프로그램이 직접 접근할 수 없기 떄문입니다.
                - 따라서 private 인스턴스 변수에도 접근할 수 있는 초기화만을 위한 public메소드가 필요합니다.
                - 이러한 초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수의 초기화를 위해 호출되어야 합니다.

            * 생성자
                - 자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자라는 메소드를 제공합니다.
                - 자바에서 생성자의 이름은 해당 클래스의 이름과 같아야 합니다.
                - 즉, Car 클래스의 생성자의 이름은 Car가 됩니다.

                - 이러한 생성자는 다음과 같은 특징을 가집니다.
                1. 생성자는 반환값이 없지만, 반환타입을 void형으로 선언하지 않습니다.
                2. 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있습니다.
                3. 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있습니다.
                   즉, 생성자도 하나의 메소드이므로, 메소드 오버로딩이 가능하다는 의미입니다.

            * 생성자의 선언
                - 자바에서 클래스 생성자를 선언하는 문법은 다음과 같습니다.
                문법
                1. 클래스이름() { ... }                  // 매개변수가 없는 생성자 선언
                2. 클래스이름(인수1, 인수2, ...) { ... } // 매개변수가 있는 생성자 선언
                - 위와 같이 생성자 중에는 매개변수를 전달받아 인스턴스 변수를 초기화하는 생성자도 선언할 수 있습니다.

            * 생성자의 호출
                - 자바에서는 new 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출됩니다.

            * 기본 생성자
                - 자바의 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 합니다.
                - 하지만 특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있습니다.
                - 이것은 자바 컴파일러가 기본 생성자라는 것을 기본적으로 제공해 주기 떄문입니다.
                - 기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않습니다.

                - 자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않으면, 자동으로 다음과 같은 기본 생성자를 추가합니다.
                문법
                클래스이름() {}
                - 하지만 만약 매개변수를 가지는 생성자를 하나라도 정의했다면, 기본 생성자는 자동으로 추가되지 않습니다.
                - 따라서 매개변수를 가지는 생성자를 하나 이상 정의한 후 기본 생성자를 호출하면, 오류가 발생할 것입니다.

        ** this와 this()
            * this 참조변수
                - this 참조변수는 인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수입니다.
                - 이러한 this 참조 변수는 해당 인스턴스의 주소를 가리키고 있습니다.
                예제
                class Car {
                    private String modelName;
                    private int modelYear;
                    private String color;
                    private int maxSpeed;
                    private int currentSpeed;

                    Car(String modelName, int modelYear, String color, int maxSpeed) {
                        this.modelName = modelName;
                        this.modelYear = modelYear;
                        this.color = color;
                        this.maxSpeed = maxSpeed;
                        this.currentSpeed = 0;
                    }
                    ...
                }
                - 위의 예제처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 인스턴스 변수 앞에 this 키워드를 붙여 구분해야만 합니다.
                - 이렇게 자바에서는 this 참조 변수를 사용하여 인스턴스 변수에 접근할 수 있습니다.
                - 이러한 this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없습니다.
                - 모든 인스턴스 메소드에는 this 참조변수가 숨겨진 지역 변수로 존재하고 있습니다.

            * this() 메소드
                - this() 메소드는 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 떄 사용합니다.
                - this() 메소드에 인수를 전달하면, 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해 줍니다.
                예제
                class Car {
                    private String modelName;
                    private int modelYear;
                    private String color;
                    private int maxSpeed;
                    private int currentSpeed;

                    Car(String modelName, int modelYear, String color, int maxSpeed) {
                        this.modelName = modelName;
                        this.modelYear = modelYear;
                        this.color = color;
                        this.maxSpeed = maxSpeed;
                        this.currentSpeed = 0;
                    }
                    Car() {
                        this("소나타", 2012, "검정색", 160); // 다른 생성자를 호출함.
                    }
                    public String getModel() {
                        return this.modelYear + "년식 " + this.modelName + " " + this.color;
                    }
                }

                public class Method05 {
                    public static void main(String[] args) {
                        Car tcpCar = new Car(); System.out.println(tcpCar.getModel());
                    }
                }
                - 위의 예제에서 매개변수를 가지는 첫 번째 생성자는 this 참조 변수를 사용하여 인스턴스 변수에 접근하고 있습니다.
                - 또한 매개변수를 가지지 않는 두 번째 생성자는 내부에서 this() 메소드를 이용하여 첫 번째 생성자를 호출합니다.
                - 이렇게 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있습니다.

        ** 메소드 오버로딩
            * 메소드 시그니처
                - 메소드 오버로딩 핵심은 바로 메소드 시그니처에 있습니다.
                - 메소드 시그니처란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킵니다.
                - 만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면, 이 두 메소드의 시그니처는 같다고 할 수 있습니다.

            * 메소드 오버로딩
                - 메소드 오버로딩이랄ㄴ 같은 이름의 메소드를 중복하여 정의하는 것을 의미합니다.
                - 자바에서는 원래 한 클래스 내에 같은 이름의 메소드를 둘 이상 가질수 없습니다.
                - 하지만 매개변수의 개수나 타입을 다르게 하면, 하나의 이름으로 메소드를 작성할 수 있습니다.
                - 즉, 메소드 오버로딩은 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이라고 할 수 있습니다.

               - 이러한 메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있습니다.
               - 또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 됩니다.
               - 메소드 오버로딩은 객체 지향 프로그래밍의 특징 중 하나인 다형성을 구현하는 방법 중 하나입니다.

               - 메소드 오버로딩의 대표적인 예로는 println() 메소드를 들 수 있습니다.
               - println() 메소드는 전달받는 매개변수의 타입에 따라 다음과 같은 다양한 원형 중에서 적절한 원형을 호출하게 됩니다.

            * 메소드 오버로딩의 조건
                - 자바에서 메소드 오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야 합니다.
                1. 메소드의 이름이 같아야합니다.
                2. 메소드의 시그니처, 즉 매개변수의 개수 또는 타입이 달라야 합니다.

                - 메소드 오버로딩은 반환 타입과는 관계가 없습니다.
                - 만약 메소드의 시그니처는 같은데 반환 타입만이 다른 경우에는 오버로딩이 성립하지 않습니다.

        ** 재귀호출
            * 재귀호출
                - 재귀호출이란 메소드 내부에서 해당 메소드가 또다시 호출되는 것을 의미합니다.
                - 이러한 재귀 호출은 자기가 자신을 계속해서 호출하므로, 끝없이 반복될 것입니다.
                - 따라서 메소드 내에 재귀 호출을 중단하도록 조건이 변경될 명령문을 반드시 포함해야합니다.
                - 프로그래밍을 처음 접하는 사람들은 이러한 재귀 호출이 왜 필요한가에 대해 이해하기 힘들 수 있습니다.
                - 하지만 재귀호출은 알고리즘이나 자료구조론에서는 매주 중요한 개념 중 하나입니다.
                - 또한, 재귀 호출을 사용하면 복잡한 문제도 매우 간단하게 논리적으로 접근하여 표현할 수 있습니다.

            * 재귀호출의 개념
                - 재귀 호출의 개념은 예제를 통해서 알아보겠습니다.
                int sum(int n) {
                    int result = 0;
                    for (int i = 1; i <= n; i++) {
                        result += i;
                    }
                    return result;
                }
                - 위의 예제에서 sum() 메소드는 재귀호출을 사용하지 않고 만든 메소드입니다.
                - 이러한 메소드는 그냥 봐서는 그 목적을 바로 알 수 없으며, 코드를 해석해야 무슨 목적으로 만든 메소드인지 알 수 있습니다.
                - 즉, 변수 i와 result는 왜 정의됐으며, for문은 왜 사용되었는지 알 수가 없습니다.
         */
    }
}
