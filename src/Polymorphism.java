public class Polymorphism {
    public static void main(String[] args) {
        /*
         ** 다형성의 개념
            * 다형성이란?
                - 다형성이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다.
                - 자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있습니다.
                - 다형성은 상속, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다.

            * 참조 변수의 다형성
                - 자바에서는 다형성을 위해 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하고 있습니다.
                - 이때 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 같거나 적어야 참조할 수 있습니다.

                - 특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있습니다.
                - 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 떄문입니다.
                - 그리고 부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있습니다.
                - 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스 멤버 개수보다 적기 떄문입니다.

                - 하지만 반대의 경우인 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없습니다.
                - 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 떄문입니다.

            * 참조 변수의 타입 변환
                - 자바에서는 참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있습니다.
                - 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있습니다.
                - 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있습니다.
                - 하지만 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 합니다.

                - 참조 변수의 타입 변환도 기본 타입의 변환과 마찬가지로 타입 캐스트 연산자(())를 사용합니다.

            * instanceof 연산자
                - 이러한 다형성으로 인해 런타임에 참조 변수가 실제로 참조하고 있는 인스턴스의 타입을 확인할 필요성이 생깁니다.
                - 자바에서는 instanceof 연산자를 제공하여, 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 확인할 수 있도록 해줍니다.

          ** 추상 클래스
            * 추상 메소드(abstract method)
                - 추상 메소드란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미합니다.
                - 자바에서 추상 메소드를 선언하여 사용하는 목적은 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함입니다.
                - 예를 들어 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는 자신에게 필요한 부분만을 재정의하여 사용함으로써 생산성이 향상되고 배포 등이 쉬워지기 떄문입니다.
                - 이러한 추상 메소드는 선언부만이 존재하며, 구현부는 작성되어 있지 않습니다.
                - 바로 이 작성되어 있지 않은 구현부를 자식 클래스에서 오버라이딩하여 사용하는 것입니다.

            * 추상 클래스(abstract class)
                - 자바에서는 하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 추상클래스라고 합니다.
                - 이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해줍니다.
                - 즉, 반드시 사용되어야 하는 메소드를 추상 클래스에 추상 메소드로 선언해 놓으면, 이 클래스를 상속받는 모든 클래스에서는 이 추상 메소드를 반드시 재정의해야 합니다.
                - 이러한 추상 클래스는 동작이 정의도이 있지 않은 추상 메소드를 포함하고 있으므로, 인스턴스를 생성할 수 없습니다.
                - 추상클래스는 먼저 상속을 통해 자식 클래스를 만들고, 만든 자식 클래스에서 추상 클래스의 모든 추상 메소드를 오버라이딩하고 나서야 비로소 자식 클래스의 인스턴스를 생성할 수 있게 됩니다.

            * 추상 메소드의 사용 목적
                - 자바에서 추상 메소드를 선언하여 사용하는 목적은 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함입니다.
                - 만약 일반 메소드로 구현한다면 사용자에 따라 해당 메소드를 구현할 수 도 있고, 안 할 수도 있습니다.
                - 하지만 추상 메소드가 포함된 추상 클래스를 상속받은 모든 자식 클래스는 추상 메소드를 구현해야만 인스턴스를 생성할 수 있으므로, 반드시 구현하게 됩니다.


          ** 인터페이스
            * 인터페이스란?
                - 자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가지게 될 것입니다.
                - 하지만 클래스를 이용하여 다중 상속을 할 경우 메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않습니다.
                - 하지만 다중 상속의 이점을 버릴 수는 없기에 자바에서는 인터페이스라는 것을 통해 다중 상속을 지원하고 있습니다.
                - 인터페이스란 다른 클래스를 작성할 떄 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상클래스를 의미합니다.
                - 자바에서 추상 클래스는 추상 메소드뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있습니다.
                - 하지만 인터페이스는 오로지 추상 메소드와 상수만을 포함할 수 있습니다.

            * 인터페이스 선언
                - 자바에서 인터페이스를 선언하는 방법은 클래스를 작성하는 방법과 같습니다.
                - 인터페이스 선언할 때에는 접근 제어자와 함꼐 interface 키워드를 사용하면 됩니다.
                - 단, 클래스와는 달리 인터페이스의 모든 필드는 public static final이어야 하며, 모든 메소드는 public abstract이어야 합니다.
                - 이 부분은 모든 인터페이스에 공통으로 적용되는 부분이므로 이 제어자는 생략할 수 있습니다.
                - 이렇게 생략된 제어자는 컴파일 시 자바 컴파일러가 자동으로 추가해 줍니다.

            * 인터페이스의 구현
                - 인터페이스는 추상 클래스와 마찬가지로 자신이 직접 인스턴스를 생성할 수는 없습니다.
                - 따라서 인터페이스가 포함하고 있는 추상 메소드를 구현해 줄 클래스를 작성해야만 합니다.
                - 만약 모든 추상 메소드를 구현하지 않는다면, abstruct 키워드를 사용하여 추상 클래스로 선언해야 합니다.

            * 클래스를 이용한 다중 상속의 문제점
                - 클래스를 이용하여 다중 상속을 하면 다음 예제와 같은 메소드 출처의 모호성 등의 문제점이 발생할 수 있습니다.

            * 인터페이스의 장점
                - 인터페이스를 사용하면 다중 상속이 가능할 뿐만 아니라 다음과 같은 장점을 가질 수 있습니다.
                - 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능합니다.
                - 클래스의 작성과 인터페이스의 구현을 동시에 진행 할 수 있으므로, 개발 시간을 단축할 수 있습니다.
                - 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 독립적인 프로그래밍이 가능합니다.

         ** 내부 클래스
            * 내부 클래스(inner class)
                - 내부 클래스란 하나의 클래스 내부에 선언된 또 다른 클래스를 의미합니다.
                - 이러한 내부 클래스는 외부 클래스에 대해 두개의 클래스가 서로 긴밀한 관계를 맺고 있을 때 선언할 수 있습니다.

            * 내부 클래스의 장점
                - 내부 클래스를 사용하면 다음과 같은 장점을 가질 수 있습니다.
                - 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있게 됩니다.
                - 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 코드의 캡슐화를 증가시킵니다.
                - 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 복잡성을 줄일 수 있습니다.

            * 내부 클래스의 종류
                - 내부 클래스의 필드와 마찬가지로 선언된 위치에 따라 다음과 같이 구분됩니다.
                - 정적 클래스
                - 인스턴스 클래스
                - 지역 클래스
                - 익명 클래스

                - 외부 클래스 영역에 선언된 클래스 중에서 static 키워드를 가지는 클래스를 정적 클래스라고 합니다.
                - 이러한 정적 클래스는 주로 외부 클래스의 클래스 메소드에 사용될 목적으로 선언됩니다.
                - 외부 클래스 영역에 선언된 클래스 중에서 static 키워드를 가지지 않는 클래스를 인스턴스 클래스라고 합니다.
                - 이러한 인스턴스 클래스는 주로 외부 클래스의 인스턴스 변수나 인스턴스 메소드에 사용될 목적으로 선언됩니다.

                - 지역 클래스란 외부 클래스의 메소드나 초기화 블록에 선언된 클래스를 의미합니다.
                - 이러한 지역 클래스는 선언된 블록 내에서만 사용할 수 있습니다.

            * 익명 클래스
                - 익명 클래스란 다른 내부 클래스와는 달리 이름을 가지지않는 클래스를 의미합니다.
                - 익명 클래스는 클래스의 선언과 동시에 객체를 생성하므로, 단 하나의 객체만을 생성하는 일회용 클래스입니다.
                - 따라서 생성자를 선언할 수도 없으며, 오로지 단 하나의 클래스나 단 하나의 인터페이스를 상속받거나 구현할 수 있을 뿐입니다.
                - 이러한 익명 클래스는 매우 제한적인 용도에 사용되며, 구현해야 하는 메소드가 매우 적은 클래스를 구현할 때 사용합니다.




         */
    }
}
