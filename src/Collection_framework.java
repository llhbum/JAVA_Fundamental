import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

public class Collection_framework {
    public static void main(String[] args) {
        /*
         ** 컬렉션 프레임워크의 개념
            * 컬렉션 프레임워크란?
                - 자바에서 컬랙션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.
                - 즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것입니다.
                - 이러한 컬렉션 프레임워크는 자바의 인터페이스를 사용하여 구현됩니다.

            * 컬렉션 프레임워크 주요 인터페이스
                - 컬렉션 프레임워크에서는 데이터를 저장하는 자료구조에 따라 다음과 같은 핵심이 되는 주요 인터페이스를 정의하고 있습니다.

                1. List 인터페이스
                2. Set 인터페이스
                3. Map 인터페이스

                - 이 중에서 List와 Set 인터페이스는 모두 Collection 인터페이스를 상속받지만 구조상의 차이로 인해 Map 인터페이스는 별도로 정의됩니다.
                - 따라서 List 인터페이스와 Set 인터페이스의 공통된 부분을 Collection 인터페이스에서 정의하고 있습니다.

            * 주요 인터페이스의 간략한 특징
                - 자바에서 컬렉션 프레임워크를 구성하고 있는 주요 인터페이스의 간략한 특징은 다음과 같습니다.
                - List<E> : 순서가 있는 데이터의 집합으로, 데이터의 중복을 허용함 : Vector, ArrayList, LinkedList, Stack, Queue
                - Set<E> : 순서가 없는 데이터의 집합으로, 데이터의 중복을 허용하지 않음 : HashSet, TreeSet
                - Map<K,V> : 키와 값의 한 쌍으로 이루어지는 데이터의 집합으로, 순서가 없음. 이떄 키는 중복을 허용하지 않지만 값은 중복을 허용함 : HashMap, TreeMap, Hashtable, Properties

            * 주요 인터페이스의 간략한 특징
                - 컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스를 컬렉션 클래스라고 합니다.
                - 컬렉션 프레임워크의 모든 컬렉션 클래스는 List와 Set, Map 인터페이스 중 하나의 인터페이스를 구현하고 있습니다.
                - 또한, 클래스 이름에도 구현한 인터페이스 이름이 포함되므로 바로 구분할 수 있습니다.

                - Vector나 Hashtable과 같은 컬렉션 클래스는 예전부터 사용해 왔으므로, 기존 코드와의 호환을 위해 아직도 남아 있습니다.
                - 하지만 기존에 사용하던 컬렉션 클래스를 사용하는 것보다는 새로 추가된 ArrayList나 HashMap 클래스를 사용하는 것이 성능 명에서도 더 나은 결과를 얻을 수 있습니다.

            * Collection 인터페이스
                - List와 Set 인터페이스의 많은 공통된 부분을 Collections 인터페이스에서 정의하고, 두 인터페이스는 그것을 상속받습니다.
                - 따라서 Collection 인터페이스는 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고, 그것을 메소드로 제공하고 있습니다.

         ** List 컬렉션 클래스
            * List 컬렉션 클래스
                - List 인터페이스를 구현한 모든 List 컬렉션 클래스는 다음과 같은 득징을 가집니다.
                1. 요소의 저장 순서가 유지됩니다.
                2. 같은 요소의 중복 저장을 허용합니다.

                - 대표적인 List 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.
                1. ArrayList<E>
                2. LinkedList<E>
                3. Vector<E>
                4. Stack<E>

            * ArrayList<E> 클래스
                - ArrayList 클래스는 가장 많이 사용되는 컬렉션 클래스 중 하나입니다.
                - JDK 1.2부터 제공된 ArrayList 클래스는 내부적으로 배열을 이용하여 요소를 저장합니다.

                - ArrayList 클래스는 배열을 이용하기 떄문에 인덱스를 이용해 배열 요소에 빠르게 접근할 수 있습니다.
                - 하지만 배열은 크기를 변경할 수 없는 인스턴스이므로, 크기를 늘리기 위해서는 새로운 배열을 생성하고 기존의 요소들을 옮겨야 하는 복잡한 과정을 거쳐야합니다.
                - 물론 이 과정은 자동으로 수행되지만, 요소의 추가 및 삭제 작업을 걸리는 시간이 매우 길어지는 단점을 가지게 됩니다.

            * LinkedList<E> 클래스
                - LinkedList 클래스는 ArrayList 클래스가 배열을 이용하여 요소를 저장함으로써 발생하는 단점을 극복하기 위해 고안되었습니다.
                - JDK 1.2 부터 제공된 LinkedList클래스는 내부적으로 연결 리스트(Linked List)를 이용하여 요소를 저장합니다.
                - 배열은 저장된 요소가 순차적으로 저장됩니다.
                - 하지만 연결 리스트는 저장된 요소가 비순차적으로 분포되며, 이러한 요소들 사이를 링크로 연결하여 구성합니다.
                - 다음 요소를 가리키는 참조만을 가지는 연결 리스트를 단일 연결 리스트 라고 합니다.

                - 이러한 단일 연결 리스트는 요소의 저장과 삭제 작업이 다음 요소를 가리키는 참조만 변경하면 되므로 아주 빠르게 처리될 수 있습니다.
                - 하지만 단일 연결 리스트는 현재 요소에서 이전 요소로 접근하기 매우 어렵습니다.
                - 따라서 요소를 가리키는 참조도 가지는 이중 연결 리스트가 좀 더 많이 사용됩니다.

                - LinkedList 클래스도 위와 같은 이중 연결 리스트를 내부적으로 구현한 것입니다.
                - 또한, LinkedList 클래스 역시 List 인터페이스를 구현하므로, ArrayList 클래스와 사용할 수 있는 메소드가 거의 같습니다.

            * Vector<E> 클래스
                - Vector 클래스는 JDK 1.0 부터 사용해 온 ArrayList클래스와 같은 동작을 수행하는 클래스 입니다.
                - 현재는 Vector 클래스는 ArrayList 클래스와 마찬가지로 List인터페이스를 상속받습니다.
                - 따라서 Vector 클래스에서 사용할 수 있는 메소드는 ArrayList클래스에서 사용할 수 있는 메소드와 거의 같습니다.
                - 하지만 현재에는 기존 코드와의 호한성을 위해서만 남아있으므로, Vector 클래스보다는 ArrayList 클래스를 사용하는 것이 좋습니다.

            * List 인터페이스 메소드
                - List 인터페이스는 Collection 인터페이스를 상속받으므로, Collection 인터페이스에서 정의한 메소드도 모두 사용할 수 있습니다.
                - List 인터페이스에서 제공하는 주요 메소드는 다음과 같습니다.
         
         ** Stack과 Queue
            * Stack<E> 클래스
                - Stack 클래스는 List 컬렉션 클래스의 Vector 클래스를 상속받아, 전형적인 스택 메모리 구조의 클래스를 제공합니다.
                - 스택 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료구조입니다.
                - 즉, 가장 나중에 저장된(PUSH) 데이터가 가장 먼저 인출(POP)되는 구조입니다.
                
                - 더욱 복잡하고 빠른 스택을 구현하고 싶다면 Deque 인터페이스를 구현한 ArrayDeque 클래스를 사용하면 됩니다.
            
            * Queue<E> 인터페이스
                - 클래스로 구현된 스택과는 달리 자바에서 큐 메모리 구조는 별도의 인터페이스 형태로 제공됩니다.
                - 이러한 Queue 인터페이스를 상속 받는 하위 인터페이스는 다음과 같습니다.
                1. Deque<E>
                2. BlockingDequq<E>
                3. BlockingQueue<E>
                4. TrasgerQueue<E>
                - 따라서 Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많습니다, 그 중에서도 Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됩니다.
                - 큐 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 선입선출(FIFO)의 시멘틱을 따르는 자료 구조입니다.
                - 즉, 가장 먼저 저장된 데이터가 가장먼저 인출되는 구조입니다.
                
                - Queue 인터페이스는 큐 메모리 구조를 표현하기 위해, 다음과 같은 Collection 인터페이스 메소드만을 상속받아 사용합니다.
                - 더욱 복잡하고 빠른 큐를 구현하고 싶다면 Deque 인터페이스를 구현한 ArrayDeque 클래스를 사용하면 됩니다.

         ** Set 컬렉션 클래스
            * Set 컬렉션 클래스
                - Set인터페이스를 구현한 모든 Set 컬렉션 클래스는 다음과 같은 특징을 가집니다.
                1. 요소의 저장 순서를 유지하지 않습니다.
                2. 같은 요소의 중복 저장을 허용하지 않습니다.

                - 대표적인 Set 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.
                1. HashSet<E>
                2. TreeSet<E>
            * HashSet<E> 클래스
                - HashSet 클래스는 Set 컬렉션 클래스에서 가장 많이 사용되는 클래스중 하나입니다.
                - JDK 1.2부터 제공된 HashSet 클래스는 해시 알고리즘(Hash algorithm)을 사용하여 검색 속도가 매우 빠릅니다.
                - 이러한 HashSet 클래스는 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장합니다.

                - HashSet 클래스는 Set 인터페이스를 구현하므로, 요소를 순서 상관없이 저장하고 중복된 값은 저장하지 않습니다.
                - 만약 요소의 저장 순서를 유지해야 한다면 JDK1.4부터 제공하는 LinkedHashSet 클래스를 사용하면 됩니다.

                - 위의 예제에서 요소의 저장 순서를 바꿔도 저장되는 순서에는 영향을 미치지 않는 것을 확인할 수 있습니다.
                - 또한, add() 메소드를 사용하여 해당 HashSet에 이미 존재하는 요소를 추가하려고 하면, 해당 요소를 저장하지 않고 false를 반환하는 것을 볼 수 있습니다.

                - 이떄 해당 HashSet에 이미 존재하는 요소인지를 파악하는 위해서는 내부적으로 다음과 같은 과정을 거치게 됩니다.
                1. 해당 요소에서 hashCode() 메소드를 호출하여 반환된 해시값으로 검색할 범위를 결정합니다.
                2. 해당 범위 내의 요소들을 equals() 메소드로 비교합니다.

                - 따라서 HashSet에서 add()메소드를 사용하여 중복없이 새로운 요소를 추가하기 위해서는 hashCode() 와 equals() 메소드를 상황에 막제 오버라이딩해야합니다.

            * 해시 알고리즘(hash Algorithm)
                - 해시 알고리즘이란 해시 함수를 사용하여 데이터를 해시 테이블에 저장하고, 다시 검색하는 알고리즘입니다.
                - 자바에서 해시 알고리즘을 이용한 자료 구조는 배열과 연결 리스트로 구현됩니다.
                - 저장할 데이터의 키값을 해시 함수에 넣어 반환되는 값으로 배열의 인덱스를 구합니다.
                - 그리고서 해당 인덱스에 저장된 연결 리스트에 데이터를 저장하게 됩니다.

                - 예를 들어,

            * TreeSet<E> 클래스
                - TreeSet클래스는 데이터가 정렬된 상태로 저장되는 이진 검색 트리의 형태로 요소를 저장합니다.
                - 이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다.
                - JDK1.2부터 제공되는 TreeSet 클래스는 NavigableSet 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리로 구현합니다.
                - TreeSet 클래스는 Set인터페이스를 구현하므로, 요소를 순서에 상관없이 저장하고 중복된 값은 저장하지 않습니다.

            * Set 인터페이스 메소드
                - Set 인터페이스는 Collection 인터페이스를 상속받으므로, Collection 인터페이스에서 정의한 메소드도 모두 사용할 수 있습니다.
                - Set 인터페이스에서 제공하는 주요 메소드

         ** Map 컬렉션 클래스
            * Map 컬렉션 클래스
                - Map 인터페이스는 Collection 인터페이스와는 다른 저장 방식을 가집니다.
                - Map 인터페이스를 구현한 Map 컬렉션 클래스들은 키와 값을 하나의 쌍으로 저장하는 방식(Key-value 방식)을 사용합니다.
                - 여기서 키(key)란 실질적인 값(value)을 찾기 위한 이름의 역할을 합니다.

                - Map 인터페이스를 구현한 모든 Map 컬렉션 클래스는 다음과 같은 특징을 가집니다.
                1. 요소의 저장 순서를 유지하지 않습니다.
                2. 키는 중복을 허용하지 않지만, 값의 중복은 허용합니다.

                - 대표적인 Map 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.
                1. HashMap<K,V>
                2. Hashtable<k,V>
                3. TreeMap<K,V>

            * HashMap<K,V> 클래스
                - HashMap 클래스는 Map 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다.
                - JDK 1.2 부터 제공된 HashMap 클래스는 해시 알고리즘을 사용하여 검색 속도가 매우 빠릅니다.

                - HashMap 클래스는 Map 인터페이스를 구현하므로, 중복된 키로는 값을 저장할 수 없습니다.
                - 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.

                - 위의 예제에서 사용된 KeySet() 메소드는 해당 맵에 포함된 모든 키 값들을 하나의 집합(Set)으로 반환해 줍니다.

            * Hashtable<K,V> 클래스
                - HasHtable 클래스는 JDK1.0부터 사용해 온 HashMap 클래스와 같은 동작을 하는 클래스입니다.
                - 현재의 Hashtable 클래스는 HashMap 클래스와 마찬가지로 Map 인터페이스를 상속받습니다.
                - 따라서 Hashtable 클래스에서 사용할 수 있는 메소드는 HashMap 클래스에서 사용할 수 있는 메소드와 거의 같습니다.
                - 하지만 현재에는 기존 코드와의 호환성을 위해서만 남아있으므로, Hashtable 클래스보다는 HashMap 클래스를 사용하는 것이 좋습니다.

            * TreeMap<K,V> 클래스
                - TreeMap 클래스는 키와 값을 한 쌍으로 하는 데이터를 이진 검색 트리의 형태로 저장합니다.
                - 이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다.
                - JDK 1.2 부터 제공된 TreeMap 클래스는 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리로 구현합니다.

                - TreeMap 클래스는 Map 인터페이스를 구현하므로, 중복된 키로는 값을 저장할 수 없습니다.
                - 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.

        ** Iterator와 Listlterator
            * Iterator<E> 인터페이스
                - 자바의 컬렉션 플레임워크는 컬렉션에 저장된 요소를 읽어 오는 방법을 Iterator 인터페이스로 표준화하고 있습니다.
                - Collection 인터페이스에서는 Iterator인터페이스를 구현한 클래스의 인스턴스를 반환하는 iterator() 메소드를 정의하여 각 요소에 접근하도록 하고 있습니다.
                - 따라서 Collection 인터페이스를 상속받는 List와 Set 인터페이스에서도 Iterator() 메소드를 사용할 수 있습니다.

            * Enumeration<E> 인터페이스
                - Enumeration 인터페이스는 JDK 1.0 부터 사용해온 Iterator 인터페이스와 같은 동작을 하는 인터페이스입니다.
                - Enumeration 인터페이스는 hasMoreElements()와 nextElement() 메소드를 사용하여 Iterator와 같은 작업을 수행합니다.
                - 하지만 현재에는 기존 코드와의 호환성을 위해서만 남아있으므로, Enumeration 인터페이스보다는 Iterator 인터페이스를 사용하는 것이 좋습니다.

            * Listlterator<E> 인터페이스
                - Listlterator 인터페이스는 Iterator 인터페이스를 상속받아 여러 기능을 추가한 인터페이스입니다.
                - Iterator 인터페이스는 컬렉션의 요소에 접근할 떄 한 방향으로만 이동할 수 있습니다.
                - 하지만 JDK 1.2부터 제공된 Listlterator인터페이스는 컬렉션 요소의 대체, 추가 그리고 인게스 검색 등을 위한 작업에서 양방향으로 이동하는 것을 지원합니다.
                - 단, Listlterator 인터페이스는 List 인터페이스를 구현한 List 컬렉션 클래스에서만 listlterator() 메소드를 통해 사용할 수 있습니다.
        ** Comparable과 Comparator
            * Comparable<T> 인터페이스
                - Comparable 인터페이스는 객체를 정렬하는 데 사용되는 메소드인 compareTo() 메소드를 정의하고 있습니다.
                - 자바에서 같은 타입의 인스턴스를 서로 비교해야만 하는 클래스들은 모두 Comparable 인터페이스를 구현하고 있습니다.
                - 따라서 Boolean을 제외한 래퍼 클래스나 String, Time, Data와 같은 클래스의 인스턴스는 모두 정렬 가능합니다.
                - 이때 기본 정렬 순서는 작은 값에서 큰 값으로 정렬되는 오름차순이 됩니다.

            * Comparator<T> 인터페이스
                - Comparator 인터페이스는 Comparable 인터페이스와 같은 객체를 정렬하는 데 사용되는 인터페이스입니다.
                - Comparable 인터페이스를 구현한 클래스는 기본적으로 오름차순으로 정렬됩니다.
                - 반면에 Comparator 인터페이스는 내림차순이나 아니면 다른 기준으로 정렬하고 싶을 때 사용할 수 있습니다.
                - 즉, Comparator 인터페이스를 구현하면 오름차순 이외의 기준으로도 정렬할 수 있게 되는 것입니다.
                - 이때, Comparator 인터페이스를 구현한 클래스에서는 compare() 메소드를 재정의하여 사용하게 됩니다.

         * */








    }
}
