public class Inheritance {
    public static void main(String[] args) {
        /*
         ** 상속이란?
                - 상속이란 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미합니다.
                - 이러한 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다.

                - 상속을 이용하면 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있습니다.
                - 이떄 기존에 정의되어 있던 클래스를 부모 클래스 또는 상위 클래스(Super class), 기초 클래스라고도 합니다.
                - 그리고 상속을 통해 새롭게 작성되는 클래스를 자식 클래스 또는 하위 클래스, 파생 클래스라고도 합니다.

           * 상속의 장점
                - 기존에 작성된 클래스를 재활용할 수 있습니다.
                - 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 됩니다.
                - 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련합니다.

           * 자식 클래스
                - 자식 클래스란 부모 클래스의 모든 특성을 물려받아 새롭게 작성된 클래스를 의미합니다.
                * class 자식클래스이름 extend 부모클래스이름 {...}
                - 부모 클래스에 새로운 필드를 하나 추가하면, 자식 클래스에도 자동으로 해당 필드가 추가된 것처럼 동작합니다.
                - 자식 클래스에는 부모 클래스의 필드와 메소드만이 상속되며, 생성자와 초기화 블록은 상속되지 않습니다.
                - 또한, 부모 클래스의 접근 제어가 private이나 default로 설정된 멤버는 자식 클래스에서 상속받지만 접근할 수는 없습니다.


           * Object 클래스
                - 자바에서 Object 클래스는 모든 클래스의 부모 클래스가 되는 클래스입니다.
                - 따라서 자바의 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 됩니다.
                - 즉, 자바의 모든 클래스는 별도로 extends 키워드를 사용하여 Object 클래스의 상속을 명시하지 않아도 Object 클래스의 모든 멤버를 자유롭게 사용할 수 있습니다.
                - 자바의 모든 객체에서 toString()이나, clone()과 같은 메소드를 바로 사용할 수 있는 이유가 해당 메소드들이 Object 클래스의 메소드이기 떄문입니다.


         ** super와 super()

            * super 키워드
                - super키워드는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는데 사용하는 참조 변수입니다.
                - 인스턴스 변수의 이름과 지역 변수의 이름이 같은 경우 인스턴스 변수 앞에 this 키워드를 사용하여 구분할 수 있었습니다.
                - 이와 마찬가지로 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super 키워드를 사용하여 구별할 수 있습니다.
                - 이렇게 자바에서는 super 참조 변수를 사용하여 부모 클래스의 멤버에 접근할 수 있습니다.
                - this와 마찬가지로 super참조 변수를 사용할 수 있는 대상도 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없습니다.

            * super() 메소드
                - this() 메소드가 같은 클래스의 다른 생성자를 호출할 때 사용된다면, super()메소드는 부모 클래스의 생성자를 호출할 떄 사용됩니다.
                - 자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 멤버뿐만 아니라 부모 클래스의 모든 멤버까지도 포함되어 있습니다.
                - 따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야한 합니다.
                - 이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 Object 클래스의 생성자까지 계속 거슬러 올라가며 수행됩니다.

                - 따라서 자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫 줄에 자동으로 다음과 같은 명령문을 추가하여, 부모 클래스의 멤버를 초기화 할 수 있도록 해줍니다.
                - 하지만 자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않아야만, 자동으로 기본 생성자를 추가해 줍니다.

         ** 메소드 오버라이딩

            * 메소드 오버라이딩
                - 앞서 배운 오버로딩이란 서로 다른 시그니처를 갖는 여러 메소드를 하나의 이름으로 정의하는 것이었습니다.
                - 오버라이딩이란 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그너쳐를 갖는 메소드로 다시 정의하는 것이라고 할 수 있습니다.
                - 자바에서 자식 클래스는 부모 클래스의 private 멤버를 제외한 모든 메소드를 상속 받습니다.
                - 이렇게 상속받는 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의 하여 사용할 수도 있습니다.
                - 즉, 메소드 오버라이딩이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미합니다.

            * 오버라이딩의 조건
                - 자바에서 메소드를 오버라이딩하기 위한 조건은 다음과 같습니다.
                - 오버라이딩이란 메소드의 동작만을 재정의하는 것이므로, 메소드의 선업부는 기존 메소드와 완전히 같아야합니다.
                - 하지만 메소드의 반환 타입은 부모 클래스의 반환 타입으로 타입 변환 할 수 있는 타입이라면 변경할 수 있습니다.
                - 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 없습니다.
                - 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없습니다.

            * 메소드 오버라이딩
                - 자바에서는 메소드 오버라이딩을 통해 상속받은 부모 클래스의 메소드를 자식 클래스에서 직접 재정의할 수 있습니다.

            * 오버로딩과 오버라이딩
                - 오버로딩과 오버라이딩은 그 단어의 유사함으로 인해 혼동하기 쉽습니다.
                - 하지만 그 개념은 확실히 다르며, 그 차이점을 아는 것이 중요합니다.
                - 간단히 정의하면 오버로딩은 새로운 메소드를 정의하는 것입니다.
                - 하지만 오버라이딩은 상속받은 기존의 메소드를 재정의하는 것입니다.

         */
    }
}
